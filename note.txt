const roles = {
  admin: {
    name: 'Admin',
    permissions: ['read', 'write', 'delete']
  },
  manager: {
    name: 'Manager',
    permissions: ['read', 'write']
  },
  user: {
    name: 'User',
    permissions: ['read', 'write', 'update_profile']
  }
};


const menu = {
  dashboard: {
    name: 'Dashboard',
    permissions: ['admin', 'manager', 'user']
  },
  users: {
    name: 'Users',
    permissions: ['admin']
  },
  products: {
    name: 'Products',
    permissions: ['admin', 'manager']
  },
  profile: {
    name: 'Profile',
    permissions: ['admin', 'manager', 'user']
  }
};


const token = jwt.sign({ userId: user.id, role: 'user' }, process.env.JWT_SECRET);


//middleware
const authorize = (permissions = []) => {
  return (req, res, next) => {
    const token = req.headers.authorization;
    if (!token) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const { role } = decoded;
      const rolePermissions = roles[role].permissions;
      if (permissions.length && !permissions.every(p => rolePermissions.includes(p))) {
        return res.status(403).json({ error: 'Forbidden' });
      }
      req.user = decoded;
      next();
    } catch (err) {
      logger.error(err);
      return res.status(401).json({ error: 'Unauthorized' });
    }
  };
};



// API Server
app.use('/api/users/:userId', authorize(['read', 'write', 'update_profile']), userRoutes);
app.use('/api/products', authorize(['read']), productRoutes);

// Menu Server
app.use('/menu', authorize(['read']), menuRoutes);




//code // utils/authorization.js
const jwt = require('jsonwebtoken');
const logger = require('./logger');

// Middleware để kiểm tra quyền truy cập dựa trên vai trò (role)
const authorize = (permissions = []) => {
  return (req, res, next) => {
    const token = req.headers.authorization;

    if (!token) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    try {
      // Giải mã token JWT để lấy thông tin người dùng
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const { role } = decoded;

      // Kiểm tra xem vai trò của người dùng có được phép thực hiện các quyền yêu cầu hay không
      if (permissions.length && !permissions.every(p => roles[role].permissions.includes(p))) {
        return res.status(403).json({ error: 'Forbidden' });
      }

      req.user = decoded;
      next();
    } catch (err) {
      logger.error(err);
      return res.status(401).json({ error: 'Unauthorized' });
    }
  };
};

module.exports = authorize;

// utils/logger.js
const winston = require('winston');

// Cấu hình bộ ghi nhật ký
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ level, message, timestamp }) => {
      return `[${timestamp}] ${level}: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

module.exports = logger;

// utils/errorHandler.js
const logger = require('./logger');

// Middleware xử lý lỗi
const errorHandler = (err, req, res, next) => {
  logger.error(err);

  res.status(err.statusCode || 500).json({
    error: err.message || 'Internal Server Error',
  });
};

module.exports = errorHandler;

// api/server.js
const express = require('express');
const userRoutes = require('./routes/userRoutes');
const productRoutes = require('./routes/productRoutes');
const logger = require('../utils/logger');
const errorHandler = require('../utils/errorHandler');
const authorize = require('../utils/authorization');

const app = express();
const port = 3000;

app.use(express.json());

// Cấu hình quyền truy cập cho các API
app.use('/api/users', authorize(['admin', 'user']), userRoutes);
app.use('/api/products', authorize(['admin', 'manager']), productRoutes);

app.use(errorHandler);

app.listen(port, () => {
  logger.info(`API server running on port ${port}`);
});

// api/routes/userRoutes.js
const express = require('express');
const userController = require('../controllers/userController');

const router = express.Router();

// Định nghĩa các đường dẫn và các hàm controller tương ứng
router.get('/', userController.getAllUsers);
router.get('/:userId', userController.getUserById);
router.post('/', userController.createUser);
router.put('/:userId', userController.updateUser);
router.delete('/:userId', userController.deleteUser);

module.exports = router;

// api/controllers/userController.js
const userService = require('../services/userService');

exports.getAllUsers = async (req, res, next) => {
  try {
    const users = await userService.getAllUsers();
    res.status(200).json(users);
  } catch (error) {
    next(error);
  }
};

exports.getUserById = async (req, res, next) => {
  try {
    const { userId } = req.params;
    const user = await userService.getUserById(userId);
    res.status(200).json(user);
  } catch (error) {
    next(error);
  }
};

exports.createUser = async (req, res, next) => {
  try {
    const newUser = await userService.createUser(req.body);
    res.status(201).json(newUser);
  } catch (error) {
    next(error);
  }
};

exports.updateUser = async (req, res, next) => {
  try {
    const { userId } = req.params;
    const updatedUser = await userService.updateUser(userId, req.body);
    res.status(200).json(updatedUser);
  } catch (error) {
    next(error);
  }
};

exports.deleteUser = async (req, res, next) => {
  try {
    const { userId } = req.params;
    await userService.deleteUser(userId);
    res.status(204).end();
  } catch (error) {
    next(error);
  }
};

// api/services/userService.js
const User = require('../models/User');

exports.getAllUsers = async () => {
  return await User.find({});
};

exports.getUserById = async (userId) => {
  return await User.findById(userId);
};

exports.createUser = async (userData) => {
  const newUser = new User(userData);
  return await newUser.save();
};

exports.updateUser = async (userId, userData) => {
  return await User.findByIdAndUpdate(userId, userData, { new: true });
};

exports.deleteUser = async (userId) => {
  return await User.findByIdAndDelete(userId);
};

// menu/server.js
const express = require('express');
const menuRoutes = require('./routes/menuRoutes');
const logger = require('../utils/logger');
const errorHandler = require('../utils/errorHandler');
const authorize = require('../utils/authorization');

const app = express();
const port = 3001;

app.use(express.json());

// Cấu hình quyền truy cập cho menu
app.use('/menu', authorize(['admin', 'manager', 'user']), menuRoutes);

app.use(errorHandler);

app.listen(port, () => {
  logger.info(`Menu server running on port ${port}`);
});

// menu/routes/menuRoutes.js
const express = require('express');
const menuController = require('../controllers/menuController');

const router = express.Router();

// Định nghĩa các đường dẫn và các hàm controller tương ứng
router.get('/', menuController.getMenu);
router.post('/', menuController.updateMenu);

module.exports = router;

// menu/controllers/menuController.js
const menuService = require('../services/menuService');

exports.getMenu = async (req, res, next) => {
  try {
    const menu = await menuService.getMenu();
    res.status(200).json(menu);
  } catch (error) {
    next(error);
  }
};

exports.updateMenu = async (req, res, next) => {
  try {
    const updatedMenu = await menuService.updateMenu(req.body);
    res.status(200).json(updatedMenu);
  } catch (error) {
    next(error);
  }
};

// menu/services/menuService.js
const Menu = require('../models/Menu');

exports.getMenu = async () => {
  return await Menu.findOne({});
};

exports.updateMenu = async (menuData) => {
  return await Menu.findOneAndUpdate({}, menuData, { new: true });
};